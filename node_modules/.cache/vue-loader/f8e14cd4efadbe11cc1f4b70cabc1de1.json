{"remainingRequest":"C:\\studiaMagisterskie\\SPDB - Przestrzenne bazy danych\\projekt\\tymApp\\SPDB2018Z\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!C:\\studiaMagisterskie\\SPDB - Przestrzenne bazy danych\\projekt\\tymApp\\SPDB2018Z\\node_modules\\vue-slider-component\\src\\vue2-slider.vue?vue&type=script&lang=js&","dependencies":[{"path":"C:\\studiaMagisterskie\\SPDB - Przestrzenne bazy danych\\projekt\\tymApp\\SPDB2018Z\\node_modules\\vue-slider-component\\src\\vue2-slider.vue","mtime":499162500000},{"path":"C:\\studiaMagisterskie\\SPDB - Przestrzenne bazy danych\\projekt\\tymApp\\SPDB2018Z\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\studiaMagisterskie\\SPDB - Przestrzenne bazy danych\\projekt\\tymApp\\SPDB2018Z\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"C:\\studiaMagisterskie\\SPDB - Przestrzenne bazy danych\\projekt\\tymApp\\SPDB2018Z\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\studiaMagisterskie\\SPDB - Przestrzenne bazy danych\\projekt\\tymApp\\SPDB2018Z\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n// Unsharp text [#166](https://github.com/NightCatSama/vue-slider-component/issues/166)\nconst roundToDPR = (function () {\n  const r = typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1\n  return value => Math.round(value * r) / r\n})()\n\nexport default {\n  name: 'VueSliderComponent',\n  props: {\n    width: {\n      type: [Number, String],\n      default: 'auto'\n    },\n    height: {\n      type: [Number, String],\n      default: 6\n    },\n    data: {\n      type: Array,\n      default: null\n    },\n    dotSize: {\n      type: Number,\n      default: 16\n    },\n    dotWidth: {\n      type: Number,\n      required: false\n    },\n    dotHeight: {\n      type: Number,\n      required: false\n    },\n    min: {\n      type: Number,\n      default: 0\n    },\n    max: {\n      type: Number,\n      default: 100\n    },\n    interval: {\n      type: Number,\n      default: 1\n    },\n    show: {\n      type: Boolean,\n      default: true\n    },\n    disabled: {\n      type: [Boolean, Array],\n      default: false\n    },\n    piecewise: {\n      type: Boolean,\n      default: false\n    },\n    tooltip: {\n      type: [String, Boolean],\n      default: 'always'\n    },\n    eventType: {\n      type: String,\n      default: 'auto'\n    },\n    direction: {\n      type: String,\n      default: 'horizontal'\n    },\n    reverse: {\n      type: Boolean,\n      default: false\n    },\n    lazy: {\n      type: Boolean,\n      default: false\n    },\n    clickable: {\n      type: Boolean,\n      default: true\n    },\n    speed: {\n      type: Number,\n      default: 0.5\n    },\n    realTime: {\n      type: Boolean,\n      default: false\n    },\n    stopPropagation: {\n      type: Boolean,\n      default: false\n    },\n    value: {\n      type: [String, Number, Array, Object],\n      default: 0\n    },\n    piecewiseLabel: {\n      type: Boolean,\n      default: false\n    },\n    debug: {\n      type: Boolean,\n      default: true\n    },\n    fixed: {\n      type: Boolean,\n      default: false\n    },\n    minRange: {\n      type: Number\n    },\n    maxRange: {\n      type: Number\n    },\n    processDragable: {\n      type: Boolean,\n      default: false\n    },\n    useKeyboard: {\n      type: Boolean,\n      default: false\n    },\n    actionsKeyboard: {\n      type: Array,\n      default () {\n        return [(i) => i - 1, (i) => i + 1]\n      }\n    },\n    piecewiseFilter: {\n      type: Function\n    },\n    tooltipMerge: {\n      type: Boolean,\n      default: true\n    },\n    startAnimation: {\n      type: Boolean,\n      default: false\n    },\n    enableCross: {\n      type: Boolean,\n      default: true\n    },\n    sliderStyle: [Array, Object, Function],\n    focusStyle: [Array, Object, Function],\n    tooltipDir: [Array, String],\n    formatter: [String, Function],\n    mergeFormatter: [String, Function],\n    piecewiseStyle: Object,\n    disabledStyle: Object,\n    piecewiseActiveStyle: Object,\n    processStyle: Object,\n    processClass: String,\n    bgStyle: Object,\n    tooltipStyle: [Array, Object, Function],\n    tooltipClass: String,\n    disabledDotStyle: [Array, Object, Function],\n    labelStyle: Object,\n    labelActiveStyle: Object\n  },\n  data () {\n    return {\n      flag: false,\n      dragFlag: false,\n      crossFlag: false,\n      keydownFlag: null,\n      focusFlag: false,\n      processFlag: false,\n      processSign: null,\n      size: 0,\n      fixedValue: 0,\n      focusSlider: 0,\n      currentValue: 0,\n      currentSlider: 0,\n      isComponentExists: true,\n      isMounted: false\n    }\n  },\n  computed: {\n    dotWidthVal () {\n      return typeof this.dotWidth === 'number' ? this.dotWidth : this.dotSize\n    },\n    dotHeightVal () {\n      return typeof this.dotHeight === 'number' ? this.dotHeight : this.dotSize\n    },\n    flowDirection () {\n      return `vue-slider-${this.direction + (this.reverse ? '-reverse' : '')}`\n    },\n    tooltipMergedPosition () {\n      if (!this.isMounted) return {}\n\n      const tooltipDirection = this.tooltipDirection[0]\n      const dot0 = this.$refs.dot0\n\n      if (dot0) {\n        if (this.direction === 'vertical') {\n          const style = {}\n          style[tooltipDirection] = `-${(this.dotHeightVal / 2) - (this.width / 2) + 9}px`\n          return style\n        } else {\n          const style = {}\n          style[tooltipDirection] = `-${(this.dotWidthVal / 2) - (this.height / 2) + 9}px`\n          style['left'] = `50%`\n          return style\n        }\n      }\n    },\n    tooltipDirection () {\n      const dir = this.tooltipDir || (this.direction === 'vertical' ? 'left' : 'top')\n      if (Array.isArray(dir)) {\n        return this.isRange ? dir : dir[1]\n      } else {\n        return this.isRange ? [dir, dir] : dir\n      }\n    },\n    tooltipStatus () {\n      return this.tooltip === 'hover' && this.flag ? 'vue-slider-always' : this.tooltip ? `vue-slider-${this.tooltip}` : ''\n    },\n    disabledArray () {\n      return Array.isArray(this.disabled) ? this.disabled : [this.disabled, this.disabled]\n    },\n    boolDisabled () {\n      return this.disabledArray.every(b => b === true)\n    },\n    isDisabled () {\n      return this.eventType === 'none' ? true : this.boolDisabled\n    },\n    disabledClass () {\n      return this.boolDisabled ? 'vue-slider-disabled' : ''\n    },\n    stateClass () {\n      return {\n        'vue-slider-state-process-drag': this.processFlag,\n        'vue-slider-state-drag': this.flag && !this.processFlag && !this.keydownFlag,\n        'vue-slider-state-focus': this.focusFlag\n      }\n    },\n    isRange () {\n      return Array.isArray(this.value)\n    },\n    slider () {\n      return this.isRange ? [this.$refs.dot0, this.$refs.dot1] : this.$refs.dot\n    },\n    minimum () {\n      return this.data ? 0 : this.min\n    },\n    val: {\n      get () {\n        return this.data ? (this.isRange ? [this.data[this.currentValue[0]], this.data[this.currentValue[1]]] : this.data[this.currentValue]) : this.currentValue\n      },\n      set (val) {\n        if (this.data) {\n          if (this.isRange) {\n            const index0 = this.data.indexOf(val[0])\n            const index1 = this.data.indexOf(val[1])\n            if (index0 > -1 && index1 > -1) {\n              this.currentValue = [index0, index1]\n            }\n          } else {\n            const index = this.data.indexOf(val)\n            if (index > -1) {\n              this.currentValue = index\n            }\n          }\n        } else {\n          this.currentValue = val\n        }\n      }\n    },\n    currentIndex () {\n      if (this.isRange) {\n        return this.data ? this.currentValue : [this.getIndexByValue(this.currentValue[0]), this.getIndexByValue(this.currentValue[1])]\n      } else {\n        return this.getIndexByValue(this.currentValue)\n      }\n    },\n    indexRange () {\n      if (this.isRange) {\n        return this.currentIndex\n      } else {\n        return [0, this.currentIndex]\n      }\n    },\n    maximum () {\n      return this.data ? (this.data.length - 1) : this.max\n    },\n    multiple () {\n      const decimals = `${this.interval}`.split('.')[1]\n      return decimals ? Math.pow(10, decimals.length) : 1\n    },\n    spacing () {\n      return this.data ? 1 : this.interval\n    },\n    total () {\n      if (this.data) {\n        return this.data.length - 1\n      } else if (Math.floor((this.maximum - this.minimum) * this.multiple) % (this.interval * this.multiple) !== 0) {\n        this.printError('Prop[interval] is illegal, Please make sure that the interval can be divisible')\n      }\n      return (this.maximum - this.minimum) / this.interval\n    },\n    gap () {\n      return this.size / this.total\n    },\n    position () {\n      return this.isRange ? [(this.currentValue[0] - this.minimum) / this.spacing * this.gap, (this.currentValue[1] - this.minimum) / this.spacing * this.gap] : ((this.currentValue - this.minimum) / this.spacing * this.gap)\n    },\n    isFixed () {\n      return this.fixed || this.minRange\n    },\n    limit () {\n      return this.isRange ? this.isFixed ? [[0, (this.total - this.fixedValue) * this.gap], [this.fixedValue * this.gap, this.size]] : [[0, this.position[1]], [this.position[0], this.size]] : [0, this.size]\n    },\n    valueLimit () {\n      return this.isRange ? this.isFixed ? [[this.minimum, this.maximum - (this.fixedValue * (this.spacing * this.multiple)) / this.multiple], [this.minimum + (this.fixedValue * (this.spacing * this.multiple)) / this.multiple, this.maximum]] : [[this.minimum, this.currentValue[1]], [this.currentValue[0], this.maximum]] : [this.minimum, this.maximum]\n    },\n    idleSlider () {\n      return this.currentSlider === 0 ? 1 : 0\n    },\n    wrapStyles () {\n      return this.direction === 'vertical' ? {\n        height: typeof this.height === 'number' ? `${this.height}px` : this.height,\n        padding: `${this.dotHeightVal / 2}px ${this.dotWidthVal / 2}px`\n      } : {\n        width: typeof this.width === 'number' ? `${this.width}px` : this.width,\n        padding: `${this.dotHeightVal / 2}px ${this.dotWidthVal / 2}px`\n      }\n    },\n    sliderStyles () {\n      if (Array.isArray(this.sliderStyle)) {\n        return this.isRange ? this.sliderStyle : this.sliderStyle[1]\n      } else if (typeof this.sliderStyle === 'function') {\n        return this.sliderStyle(this.val, this.currentIndex)\n      } else {\n        return this.isRange ? [this.sliderStyle, this.sliderStyle] : this.sliderStyle\n      }\n    },\n    focusStyles () {\n      if (Array.isArray(this.focusStyle)) {\n        return this.isRange ? this.focusStyle : this.focusStyle[1]\n      } else if (typeof this.focusStyle === 'function') {\n        return this.focusStyle(this.val, this.currentIndex)\n      } else {\n        return this.isRange ? [this.focusStyle, this.focusStyle] : this.focusStyle\n      }\n    },\n    disabledDotStyles () {\n      const disabledStyle = this.disabledDotStyle\n      if (Array.isArray(disabledStyle)) {\n        return disabledStyle\n      } else if (typeof disabledStyle === 'function') {\n        const style = disabledStyle(this.val, this.currentIndex)\n        return Array.isArray(style) ? style : [style, style]\n      } else if (disabledStyle) {\n        return [disabledStyle, disabledStyle]\n      } else {\n        return [{\n          backgroundColor: '#ccc'\n        }, {\n          backgroundColor: '#ccc'\n        }]\n      }\n    },\n    tooltipStyles () {\n      if (Array.isArray(this.tooltipStyle)) {\n        return this.isRange ? this.tooltipStyle : this.tooltipStyle[1]\n      } else if (typeof this.tooltipStyle === 'function') {\n        return this.tooltipStyle(this.val, this.currentIndex)\n      } else {\n        return this.isRange ? [this.tooltipStyle, this.tooltipStyle] : this.tooltipStyle\n      }\n    },\n    elemStyles () {\n      return this.direction === 'vertical' ? {\n        width: `${this.width}px`,\n        height: '100%'\n      } : {\n        height: `${this.height}px`\n      }\n    },\n    dotStyles () {\n      return this.direction === 'vertical' ? {\n        width: `${this.dotWidthVal}px`,\n        height: `${this.dotHeightVal}px`,\n        left: `${(-(this.dotWidthVal - this.width) / 2)}px`\n      } : {\n        width: `${this.dotWidthVal}px`,\n        height: `${this.dotHeightVal}px`,\n        top: `${(-(this.dotHeightVal - this.height) / 2)}px`\n      }\n    },\n    piecewiseDotStyle () {\n      return this.direction === 'vertical' ? {\n        width: `${this.width}px`,\n        height: `${this.width}px`\n      } : {\n        width: `${this.height}px`,\n        height: `${this.height}px`\n      }\n    },\n    piecewiseDotWrap () {\n      if (!this.piecewise && !this.piecewiseLabel) {\n        return false\n      }\n\n      let arr = []\n      for (let i = 0; i <= this.total; i++) {\n        const style = this.direction === 'vertical' ? {\n          bottom: `${this.gap * i - this.width / 2}px`,\n          left: 0\n        } : {\n          left: `${this.gap * i - this.height / 2}px`,\n          top: 0\n        }\n        const index = this.reverse ? (this.total - i) : i\n        const label = this.data ? this.data[index] : (this.spacing * index) + this.min\n        if (this.piecewiseFilter && !this.piecewiseFilter({ index, label })) {\n          continue\n        }\n        arr.push({\n          style,\n          index,\n          label: this.formatter ? this.formatting(label) : label\n        })\n      }\n      return arr\n    }\n  },\n  watch: {\n    value (val) {\n      this.flag || this.setValue(val, true)\n    },\n    max (val) {\n      if (val < this.min) {\n        return this.printError('The maximum value can not be less than the minimum value.')\n      }\n\n      const resetVal = this.limitValue(this.val)\n      this.setValue(resetVal)\n      this.refresh()\n    },\n    min (val) {\n      if (val > this.max) {\n        return this.printError('The minimum value can not be greater than the maximum value.')\n      }\n\n      const resetVal = this.limitValue(this.val)\n      this.setValue(resetVal)\n      this.refresh()\n    },\n    show (bool) {\n      if (bool && !this.size) {\n        this.$nextTick(() => {\n          this.refresh()\n        })\n      }\n    },\n    fixed () {\n      this.computedFixedValue()\n    },\n    minRange () {\n      this.computedFixedValue()\n    },\n    reverse () {\n      this.$refs.process.style.cssText = ''\n      this.refresh()\n    }\n  },\n  methods: {\n    bindEvents () {\n      document.addEventListener('touchmove', this.moving, {passive: false})\n      document.addEventListener('touchend', this.moveEnd, {passive: false})\n      document.addEventListener('mousedown', this.blurSlider)\n      document.addEventListener('mousemove', this.moving)\n      document.addEventListener('mouseup', this.moveEnd)\n      document.addEventListener('mouseleave', this.moveEnd)\n      document.addEventListener('keydown', this.handleKeydown)\n      document.addEventListener('keyup', this.handleKeyup)\n      window.addEventListener('resize', this.refresh)\n\n      if (this.isRange && this.tooltipMerge) {\n        this.$refs.dot0.addEventListener('transitionend', this.handleOverlapTooltip)\n        this.$refs.dot1.addEventListener('transitionend', this.handleOverlapTooltip)\n      }\n    },\n    unbindEvents () {\n      document.removeEventListener('touchmove', this.moving)\n      document.removeEventListener('touchend', this.moveEnd)\n      document.removeEventListener('mousedown', this.blurSlider)\n      document.removeEventListener('mousemove', this.moving)\n      document.removeEventListener('mouseup', this.moveEnd)\n      document.removeEventListener('mouseleave', this.moveEnd)\n      document.removeEventListener('keydown', this.handleKeydown)\n      document.removeEventListener('keyup', this.handleKeyup)\n      window.removeEventListener('resize', this.refresh)\n\n      if (this.isRange && this.tooltipMerge) {\n        this.$refs.dot0.removeEventListener('transitionend', this.handleOverlapTooltip)\n        this.$refs.dot1.removeEventListener('transitionend', this.handleOverlapTooltip)\n      }\n    },\n    handleKeydown (e) {\n      if (!this.useKeyboard || !this.focusFlag) {\n        return false\n      }\n      switch (e.keyCode) {\n      case 37:\n      case 40:\n        e.preventDefault()\n        this.keydownFlag = true\n        this.flag = true\n        this.changeFocusSlider(this.actionsKeyboard[0])\n        break\n      case 38:\n      case 39:\n        e.preventDefault()\n        this.keydownFlag = true\n        this.flag = true\n        this.changeFocusSlider(this.actionsKeyboard[1])\n        break\n      }\n    },\n    handleKeyup () {\n      if (this.keydownFlag) {\n        this.keydownFlag = false\n        this.flag = false\n      }\n    },\n    changeFocusSlider (fn) {\n      if (this.isRange) {\n        let arr = this.currentIndex.map((index, i) => {\n          if (i === this.focusSlider || this.fixed) {\n            const val = fn(index)\n            const range = this.fixed ? this.valueLimit[i] : [0, this.total]\n            if (val <= range[1] && val >= range[0]) {\n              return val\n            }\n          }\n          return index\n        })\n        if (arr[0] > arr[1]) {\n          this.focusSlider = this.focusSlider === 0 ? 1 : 0\n          arr = arr.reverse()\n        }\n        this.setIndex(arr)\n      } else {\n        this.setIndex(fn(this.currentIndex))\n      }\n    },\n    blurSlider (e) {\n      const dot = this.isRange ? this.$refs[`dot${this.focusSlider}`] : this.$refs.dot\n      if (!dot || dot === e.target || dot.contains(e.target)) {\n        return false\n      }\n      this.focusFlag = false\n    },\n    formatting (value) {\n      return typeof this.formatter === 'string' ? this.formatter.replace(/\\{value\\}/, value) : this.formatter(value)\n    },\n    mergeFormatting (value1, value2) {\n      return typeof this.mergeFormatter === 'string' ? this.mergeFormatter.replace(/\\{(value1|value2)\\}/g, (_, key) => key === 'value1' ? value1 : value2) : this.mergeFormatter(value1, value2)\n    },\n    getPos (e) {\n      this.realTime && this.getStaticData()\n      return this.direction === 'vertical' ? (this.reverse ? (e.pageY - this.offset) : (this.size - (e.pageY - this.offset))) : (this.reverse ? (this.size - (e.clientX - this.offset)) : (e.clientX - this.offset))\n    },\n    processClick (e) {\n      if (this.fixed) {\n        e.stopPropagation()\n      }\n    },\n    wrapClick (e) {\n      if (this.isDisabled || !this.clickable || this.processFlag || this.dragFlag) return false\n      const pos = this.getPos(e)\n      if (this.isRange) {\n        if (this.disabledArray.every(b => b === false)) {\n          this.currentSlider = pos > ((this.position[1] - this.position[0]) / 2 + this.position[0]) ? 1 : 0\n        } else if (this.disabledArray[0]) {\n          if (pos < this.position[0]) return false\n          this.currentSlider = 1\n        } else if (this.disabledArray[1]) {\n          if (pos > this.position[1]) return false\n          this.currentSlider = 0\n        }\n      }\n      if (this.disabledArray[this.currentSlider]) {\n        return false\n      }\n      this.setValueOnPos(pos)\n\n      if (this.isRange && this.tooltipMerge) {\n        const timer = setInterval(() => this.handleOverlapTooltip(), 16.7)\n        setTimeout(() => window.clearInterval(timer), this.speed * 1000)\n      }\n    },\n    moveStart (e, index = 0, isProcess) {\n      if (this.disabledArray[index]) {\n        return false\n      }\n      if (this.stopPropagation) {\n        e.stopPropagation()\n      }\n      if (this.isRange) {\n        this.currentSlider = index\n\n        if (isProcess) {\n          if (!this.processDragable) {\n            return false\n          }\n          this.processFlag = true\n          this.processSign = {\n            pos: this.position,\n            start: this.getPos((e.targetTouches && e.targetTouches[0]) ? e.targetTouches[0] : e)\n          }\n        }\n\n        if (!this.enableCross && this.val[0] === this.val[1]) {\n          this.crossFlag = true\n        }\n      }\n      if (!isProcess && this.useKeyboard) {\n        this.focusFlag = true\n        this.focusSlider = index\n      }\n      this.flag = true\n      this.$emit('drag-start', this)\n    },\n    moving (e) {\n      if (this.stopPropagation) {\n        e.stopPropagation()\n      }\n\n      if (!this.flag) return false\n      e.preventDefault()\n\n      if (e.targetTouches && e.targetTouches[0]) e = e.targetTouches[0]\n      if (this.processFlag) {\n        this.currentSlider = 0\n        this.setValueOnPos(this.processSign.pos[0] + this.getPos(e) - this.processSign.start, true)\n        this.currentSlider = 1\n        this.setValueOnPos(this.processSign.pos[1] + this.getPos(e) - this.processSign.start, true)\n      } else {\n        this.dragFlag = true\n        this.setValueOnPos(this.getPos(e), true)\n      }\n\n      if (this.isRange && this.tooltipMerge) {\n        this.handleOverlapTooltip()\n      }\n\n      this.$emit('drag', this)\n    },\n    moveEnd (e) {\n      if (this.stopPropagation) {\n        e.stopPropagation()\n      }\n      if (this.flag) {\n        this.$emit('drag-end', this)\n        if (this.lazy && this.isDiff(this.val, this.value)) {\n          this.syncValue()\n        }\n      } else {\n        return false\n      }\n      this.flag = false\n      window.setTimeout(() => {\n        this.crossFlag = false\n        this.dragFlag = false\n        this.processFlag = false\n      }, 0)\n      this.setPosition()\n    },\n    setValueOnPos (pos, isDrag) {\n      const range = this.isRange ? this.limit[this.currentSlider] : this.limit\n      const valueRange = this.isRange ? this.valueLimit[this.currentSlider] : this.valueLimit\n      const index = Math.round(pos / this.gap)\n      if (pos >= range[0] && pos <= range[1]) {\n        const v = this.getValueByIndex(index)\n        this.setTransform(pos)\n        this.setCurrentValue(v, isDrag)\n        if (this.isRange && (this.fixed || this.isLessRange(pos, index))) {\n          this.setTransform(pos + ((this.fixedValue * this.gap) * (this.currentSlider === 0 ? 1 : -1)), true)\n          this.setCurrentValue((v * this.multiple + (this.fixedValue * this.spacing * this.multiple * (this.currentSlider === 0 ? 1 : -1))) / this.multiple, isDrag, true)\n        }\n      } else {\n        const anotherSlider = pos < range[0] ? 0 : 1\n        const currentSlider = anotherSlider === 0 ? 1 : 0\n        this.setTransform(range[anotherSlider])\n        this.setCurrentValue(valueRange[anotherSlider])\n        if (this.isRange && (this.fixed || this.isLessRange(pos, index))) {\n          this.setTransform(this.limit[this.idleSlider][anotherSlider], true)\n          this.setCurrentValue(this.valueLimit[this.idleSlider][anotherSlider], isDrag, true)\n        } else if (this.isRange && (this.enableCross || this.crossFlag) && !this.isFixed && !this.disabledArray[anotherSlider] && this.currentSlider === currentSlider) {\n          this.focusSlider = anotherSlider\n          this.currentSlider = anotherSlider\n        }\n      }\n      this.crossFlag = false\n    },\n    isLessRange (pos, index) {\n      if (!this.isRange || (!this.minRange && !this.maxRange)) {\n        return false\n      }\n\n      const diff = this.currentSlider === 0 ? this.currentIndex[1] - index : index - this.currentIndex[0]\n      if (this.minRange && diff <= this.minRange) {\n        this.fixedValue = this.minRange\n        return true\n      }\n      if (this.maxRange && diff >= this.maxRange) {\n        this.fixedValue = this.maxRange\n        return true\n      }\n      this.computedFixedValue()\n      return false\n    },\n    isDiff (a, b) {\n      if (Object.prototype.toString.call(a) !== Object.prototype.toString.call(b)) {\n        return true\n      } else if (Array.isArray(a) && a.length === b.length) {\n        return a.some((v, i) => v !== b[i])\n      }\n      return a !== b\n    },\n    setCurrentValue (val, isDrag, isIdleSlider) {\n      const slider = isIdleSlider ? this.idleSlider : this.currentSlider\n      if (val < this.minimum || val > this.maximum) return false\n      if (this.isRange) {\n        if (this.isDiff(this.currentValue[slider], val)) {\n          this.currentValue.splice(slider, 1, val)\n          if (!this.lazy || !this.flag) {\n            this.syncValue()\n          }\n        }\n      } else if (this.isDiff(this.currentValue, val)) {\n        this.currentValue = val\n        if (!this.lazy || !this.flag) {\n          this.syncValue()\n        }\n      }\n      isDrag || this.setPosition()\n    },\n    getValueByIndex (index) {\n      return ((this.spacing * this.multiple) * index + (this.minimum * this.multiple)) / this.multiple\n    },\n    getIndexByValue (value) {\n      return Math.round((value - this.minimum) * this.multiple) / (this.spacing * this.multiple)\n    },\n    setIndex (val) {\n      if (Array.isArray(val) && this.isRange) {\n        let value\n        if (this.data) {\n          value = [this.data[val[0]], this.data[val[1]]]\n        } else {\n          value = [this.getValueByIndex(val[0]), this.getValueByIndex(val[1])]\n        }\n        this.setValue(value)\n      } else {\n        val = this.getValueByIndex(val)\n        if (this.isRange) {\n          this.currentSlider = val > ((this.currentValue[1] - this.currentValue[0]) / 2 + this.currentValue[0]) ? 1 : 0\n        }\n        this.setCurrentValue(val)\n      }\n    },\n    setValue (val, noCb, speed) {\n      if (this.isDiff(this.val, val)) {\n        const resetVal = this.limitValue(val)\n        this.val = this.isRange ? resetVal.concat() : resetVal\n        this.computedFixedValue()\n        this.syncValue(noCb)\n      }\n\n      this.$nextTick(() => this.setPosition(speed))\n    },\n    computedFixedValue () {\n      if (!this.isFixed) {\n        this.fixedValue = 0\n        return false\n      }\n\n      this.fixedValue = Math.max(this.fixed ? this.currentIndex[1] - this.currentIndex[0] : 0, this.minRange || 0)\n    },\n    setPosition (speed) {\n      this.flag || this.setTransitionTime(speed === undefined ? this.speed : speed)\n      if (this.isRange) {\n        this.setTransform(this.position[0], this.currentSlider === 1)\n        this.setTransform(this.position[1], this.currentSlider === 0)\n      } else {\n        this.setTransform(this.position)\n      }\n      this.flag || this.setTransitionTime(0)\n    },\n    setTransform (val, isIdleSlider) {\n      const slider = isIdleSlider ? this.idleSlider : this.currentSlider\n      const value = roundToDPR((this.direction === 'vertical' ? ((this.dotHeightVal / 2) - val) : (val - (this.dotWidthVal / 2))) * (this.reverse ? -1 : 1))\n      const translateValue = this.direction === 'vertical' ? `translateY(${value}px)` : `translateX(${value}px)`\n      const processSize = this.fixed ? `${this.fixedValue * this.gap}px` : `${slider === 0 ? this.position[1] - val : val - this.position[0]}px`\n      const processPos = this.fixed ? `${slider === 0 ? val : (val - this.fixedValue * this.gap)}px` : `${slider === 0 ? val : this.position[0]}px`\n      if (this.isRange) {\n        this.slider[slider].style.transform = translateValue\n        this.slider[slider].style.WebkitTransform = translateValue\n        this.slider[slider].style.msTransform = translateValue\n        if (this.direction === 'vertical') {\n          this.$refs.process.style.height = processSize\n          this.$refs.process.style[this.reverse ? 'top' : 'bottom'] = processPos\n        } else {\n          this.$refs.process.style.width = processSize\n          this.$refs.process.style[this.reverse ? 'right' : 'left'] = processPos\n        }\n      } else {\n        this.slider.style.transform = translateValue\n        this.slider.style.WebkitTransform = translateValue\n        this.slider.style.msTransform = translateValue\n        if (this.direction === 'vertical') {\n          this.$refs.process.style.height = `${val}px`\n          this.$refs.process.style[this.reverse ? 'top' : 'bottom'] = 0\n        } else {\n          this.$refs.process.style.width = `${val}px`\n          this.$refs.process.style[this.reverse ? 'right' : 'left'] = 0\n        }\n      }\n    },\n    setTransitionTime (time) {\n      // In order to avoid browser merge style and modify together\n      time || this.$refs.process.offsetWidth\n\n      if (this.isRange) {\n        for (let i = 0; i < this.slider.length; i++) {\n          this.slider[i].style.transitionDuration = `${time}s`\n          this.slider[i].style.WebkitTransitionDuration = `${time}s`\n        }\n        this.$refs.process.style.transitionDuration = `${time}s`\n        this.$refs.process.style.WebkitTransitionDuration = `${time}s`\n      } else {\n        this.slider.style.transitionDuration = `${time}s`\n        this.slider.style.WebkitTransitionDuration = `${time}s`\n        this.$refs.process.style.transitionDuration = `${time}s`\n        this.$refs.process.style.WebkitTransitionDuration = `${time}s`\n      }\n    },\n    limitValue (val) {\n      if (this.data) {\n        return val\n      }\n\n      const inRange = (v) => {\n        if (v < this.min) {\n          this.printError(`The value of the slider is ${val}, the minimum value is ${this.min}, the value of this slider can not be less than the minimum value`)\n          return this.min\n        } else if (v > this.max) {\n          this.printError(`The value of the slider is ${val}, the maximum value is ${this.max}, the value of this slider can not be greater than the maximum value`)\n          return this.max\n        }\n        return v\n      }\n\n      if (this.isRange) {\n        return val.map((v) => inRange(v))\n      } else {\n        return inRange(val)\n      }\n    },\n    isActive (index) {\n      return index >= this.indexRange[0] && index <= this.indexRange[1]\n    },\n    syncValue (noCb) {\n      let val = this.isRange ? this.val.concat() : this.val\n      this.$emit('input', val)\n      this.keydownFlag && this.$emit('on-keypress', val)\n      noCb || this.$emit('callback', val)\n    },\n    getValue () {\n      return this.val\n    },\n    getIndex () {\n      return this.currentIndex\n    },\n    getStaticData () {\n      if (this.$refs.elem) {\n        this.size = this.direction === 'vertical' ? this.$refs.elem.offsetHeight : this.$refs.elem.offsetWidth\n        this.offset = this.direction === 'vertical' ? (this.$refs.elem.getBoundingClientRect().top + window.pageYOffset || document.documentElement.scrollTop) : this.$refs.elem.getBoundingClientRect().left\n      }\n    },\n    refresh () {\n      if (this.$refs.elem) {\n        this.getStaticData()\n        this.computedFixedValue()\n        this.setPosition(0)\n      }\n    },\n    printError (msg) {\n      if (this.debug) {\n        console.error(`[VueSlider error]: ${msg}`)\n      }\n    },\n    handleOverlapTooltip () {\n      const isDirectionSame = this.tooltipDirection[0] === this.tooltipDirection[1]\n\n      if (this.isRange && isDirectionSame) {\n        const tooltip0 = this.reverse ? this.$refs.tooltip1 : this.$refs.tooltip0\n        const tooltip1 = this.reverse ? this.$refs.tooltip0 : this.$refs.tooltip1\n        const tooltip0Rect = tooltip0.getBoundingClientRect()\n        const tooltip1Rect = tooltip1.getBoundingClientRect()\n\n        const tooltip0Right = tooltip0Rect.right\n        const tooltip1Left = tooltip1Rect.left\n\n        const tooltip0Y = tooltip0Rect.top\n        const tooltip1Y = tooltip1Rect.top + tooltip1Rect.height\n\n        const horizontalOverlap = this.direction === 'horizontal' && tooltip0Right > tooltip1Left\n        const verticalOverlap = this.direction === 'vertical' && tooltip1Y > tooltip0Y\n\n        if (horizontalOverlap || verticalOverlap) {\n          this.handleDisplayMergedTooltip(true)\n        } else {\n          this.handleDisplayMergedTooltip(false)\n        }\n      }\n    },\n    handleDisplayMergedTooltip (show) {\n      const tooltip0 = this.$refs.tooltip0\n      const tooltip1 = this.$refs.tooltip1\n      const mergedTooltip = this.$refs.process.getElementsByClassName('vue-merged-tooltip')[0]\n\n      if (show) {\n        tooltip0.style.visibility = 'hidden'\n        tooltip1.style.visibility = 'hidden'\n        mergedTooltip.style.visibility = 'inherit'\n      } else {\n        tooltip0.style.visibility = 'inherit'\n        tooltip1.style.visibility = 'inherit'\n        mergedTooltip.style.visibility = 'hidden'\n      }\n    }\n  },\n  mounted () {\n    this.isComponentExists = true\n\n    if (typeof window === 'undefined' || typeof document === 'undefined') {\n      return this.printError('window or document is undefined, can not be initialization.')\n    }\n\n    this.$nextTick(() => {\n      if (this.isComponentExists) {\n        this.getStaticData()\n        this.setValue(this.limitValue(this.value), true, this.startAnimation ? this.speed : 0)\n        this.bindEvents()\n\n        if (this.isRange && this.tooltipMerge && !this.startAnimation) {\n          this.$nextTick(() => {\n            this.handleOverlapTooltip()\n          })\n        }\n      }\n    })\n\n    this.isMounted = true\n  },\n  beforeDestroy () {\n    this.isComponentExists = false\n    this.unbindEvents()\n  }\n}\n",{"version":3,"sources":["vue2-slider.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkLA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA","file":"vue2-slider.vue","sourceRoot":"node_modules\\vue-slider-component\\src","sourcesContent":["<template>\n  <div\n    ref=\"wrap\"\n    :class=\"['vue-slider-component', flowDirection, disabledClass, stateClass, { 'vue-slider-has-label': piecewiseLabel }]\"\n    v-show=\"show\"\n    :style=\"[wrapStyles, boolDisabled ? disabledStyle : null]\"\n    @click=\"wrapClick\"\n  >\n    <div ref=\"elem\" aria-hidden=\"true\" class=\"vue-slider\" :style=\"[elemStyles, bgStyle]\">\n      <template v-if=\"isRange\">\n        <div\n          ref=\"dot0\"\n          key=\"dot0\"\n          :class=\"[\n            tooltipStatus,\n            'vue-slider-dot',\n            {\n              'vue-slider-dot-focus': focusFlag && focusSlider === 0,\n              'vue-slider-dot-dragging': flag && currentSlider === 0,\n              'vue-slider-dot-disabled': !boolDisabled && disabledArray[0]\n            }\n          ]\"\n          :style=\"dotStyles\"\n          @mousedown=\"moveStart($event, 0)\"\n          @touchstart=\"moveStart($event, 0)\"\n        >\n          <slot name=\"dot\" :value=\"val[0]\" :index=\"0\" :disabled=\"disabledArray[0]\">\n            <div\n              class=\"vue-slider-dot-handle\"\n              :style=\"[\n                (!boolDisabled && disabledArray[0])\n                ? disabledDotStyles[0]\n                : null,\n                sliderStyles[0],\n                focusFlag && focusSlider === 0 ? focusStyles[0]: null\n              ]\"\n            ></div>\n          </slot>\n          <div ref=\"tooltip0\" :class=\"['vue-slider-tooltip-' + tooltipDirection[0], 'vue-slider-tooltip-wrap']\">\n            <slot name=\"tooltip\" :value=\"val[0]\" :index=\"0\" :disabled=\"!boolDisabled && disabledArray[0]\">\n              <span class=\"vue-slider-tooltip\"  :class=\"tooltipClass\" :style=\"tooltipStyles[0]\">{{ formatter ? formatting(val[0]) : val[0] }}</span>\n            </slot>\n          </div>\n        </div>\n        <div\n          ref=\"dot1\"\n          key=\"dot1\"\n          :class=\"[\n            tooltipStatus,\n            'vue-slider-dot',\n            {\n              'vue-slider-dot-focus': focusFlag && focusSlider === 1,\n              'vue-slider-dot-dragging': flag && currentSlider === 1,\n              'vue-slider-dot-disabled': !boolDisabled && disabledArray[1]\n            }\n          ]\"\n          :style=\"dotStyles\"\n          @mousedown=\"moveStart($event, 1)\"\n          @touchstart=\"moveStart($event, 1)\"\n        >\n          <slot name=\"dot\" :value=\"val[1]\" :index=\"1\" :disabled=\"disabledArray[1]\">\n            <div\n              class=\"vue-slider-dot-handle\"\n              :style=\"[\n                (!boolDisabled && disabledArray[1])\n                ? disabledDotStyles[1]\n                : null,\n                sliderStyles[1],\n                focusFlag && focusSlider === 1 ? focusStyles[1]: null\n              ]\"\n            ></div>\n          </slot>\n          <div ref=\"tooltip1\" :class=\"['vue-slider-tooltip-' + tooltipDirection[1], 'vue-slider-tooltip-wrap']\">\n            <slot name=\"tooltip\" :value=\"val[1]\" :index=\"1\" :disabled=\"!boolDisabled && disabledArray[1]\">\n              <span class=\"vue-slider-tooltip\" :class=\"tooltipClass\" :style=\"tooltipStyles[1]\">{{ formatter ? formatting(val[1]) : val[1] }}</span>\n            </slot>\n          </div>\n        </div>\n      </template>\n      <template v-else>\n        <div\n          ref=\"dot\"\n          key=\"dot\"\n          :class=\"[\n            tooltipStatus,\n            'vue-slider-dot',\n            {\n              'vue-slider-dot-focus': focusFlag && focusSlider === 0,\n              'vue-slider-dot-dragging': flag && currentSlider === 0\n            }\n          ]\"\n          :style=\"dotStyles\"\n          @mousedown=\"moveStart\"\n          @touchstart=\"moveStart\"\n        >\n          <slot name=\"dot\" :value=\"val\" :disabled=\"boolDisabled\">\n            <div\n              class=\"vue-slider-dot-handle\"\n              :style=\"[\n                sliderStyles,\n                focusFlag && focusSlider === 0 ? focusStyles : null\n              ]\"\n            ></div>\n          </slot>\n          <div :class=\"['vue-slider-tooltip-' + tooltipDirection, 'vue-slider-tooltip-wrap']\">\n            <slot name=\"tooltip\" :value=\"val\">\n              <span class=\"vue-slider-tooltip\"  :class=\"tooltipClass\" :style=\"tooltipStyles\">{{ formatter ? formatting(val) : val }}</span>\n            </slot>\n          </div>\n        </div>\n      </template>\n      <ul class=\"vue-slider-piecewise\">\n        <li\n          v-for=\"(piecewiseObj, index) in piecewiseDotWrap\"\n          class=\"vue-slider-piecewise-item\"\n          :style=\"[piecewiseDotStyle, piecewiseObj.style]\"\n          :key=\"index\"\n        >\n          <slot\n            name=\"piecewise\"\n            :value=\"val\"\n            :label=\"piecewiseObj.label\"\n            :index=\"index\"\n            :first=\"index === 0\"\n            :last=\"index === piecewiseDotWrap.length - 1\"\n            :active=\"isActive(piecewiseObj.index)\"\n          >\n            <span\n              v-if=\"piecewise\"\n              class=\"vue-slider-piecewise-dot\"\n              :style=\"[ piecewiseStyle, isActive(piecewiseObj.index) ? piecewiseActiveStyle : null ]\"\n            ></span>\n          </slot>\n\n          <slot\n            name=\"label\"\n            :value=\"val\"\n            :label=\"piecewiseObj.label\"\n            :index=\"index\"\n            :first=\"index === 0\"\n            :last=\"index === piecewiseDotWrap.length - 1\"\n            :active=\"isActive(piecewiseObj.index)\"\n          >\n            <span\n              v-if=\"piecewiseLabel\"\n              class=\"vue-slider-piecewise-label\"\n              :style=\"[ labelStyle, isActive(piecewiseObj.index) ? labelActiveStyle : null ]\"\n            >\n              {{ piecewiseObj.label }}\n            </span>\n          </slot>\n        </li>\n      </ul>\n      <div\n        ref=\"process\"\n        :class=\"['vue-slider-process', { 'vue-slider-process-dragable': isRange && processDragable }, processClass]\"\n        :style=\"processStyle\"\n        @click=\"processClick\"\n        @mousedown=\"moveStart($event, 0, true)\"\n        @touchstart=\"moveStart($event, 0, true)\"\n      >\n      <div\n        ref=\"mergedTooltip\"\n        :class=\"['vue-merged-tooltip', 'vue-slider-tooltip-' + tooltipDirection[0], 'vue-slider-tooltip-wrap']\"\n        :style=\"tooltipMergedPosition\"\n      >\n          <slot name=\"tooltip\" :value=\"val\" :merge=\"true\">\n            <span class=\"vue-slider-tooltip\" :class=\"tooltipClass\"  :style=\"tooltipStyles\">\n              {{ mergeFormatter ? mergeFormatting(val[0], val[1]) : (formatter ? (val[0] === val[1] ? formatting(val[0]) : `${formatting(val[0])} - ${formatting(val[1])}`) : (val[0] === val[1] ? val[0] : `${val[0]} - ${val[1]}`)) }}\n            </span>\n          </slot>\n      </div>\n    </div>\n    <input v-if=\"!isRange && !data\" class=\"vue-slider-sr-only\" type=\"range\" v-model=\"val\" :min=\"min\" :max=\"max\" />\n    </div>\n  </div>\n</template>\n<script>\n  // Unsharp text [#166](https://github.com/NightCatSama/vue-slider-component/issues/166)\n  const roundToDPR = (function () {\n    const r = typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1\n    return value => Math.round(value * r) / r\n  })()\n\n  export default {\n    name: 'VueSliderComponent',\n    props: {\n      width: {\n        type: [Number, String],\n        default: 'auto'\n      },\n      height: {\n        type: [Number, String],\n        default: 6\n      },\n      data: {\n        type: Array,\n        default: null\n      },\n      dotSize: {\n        type: Number,\n        default: 16\n      },\n      dotWidth: {\n        type: Number,\n        required: false\n      },\n      dotHeight: {\n        type: Number,\n        required: false\n      },\n      min: {\n        type: Number,\n        default: 0\n      },\n      max: {\n        type: Number,\n        default: 100\n      },\n      interval: {\n        type: Number,\n        default: 1\n      },\n      show: {\n        type: Boolean,\n        default: true\n      },\n      disabled: {\n        type: [Boolean, Array],\n        default: false\n      },\n      piecewise: {\n        type: Boolean,\n        default: false\n      },\n      tooltip: {\n        type: [String, Boolean],\n        default: 'always'\n      },\n      eventType: {\n        type: String,\n        default: 'auto'\n      },\n      direction: {\n        type: String,\n        default: 'horizontal'\n      },\n      reverse: {\n        type: Boolean,\n        default: false\n      },\n      lazy: {\n        type: Boolean,\n        default: false\n      },\n      clickable: {\n        type: Boolean,\n        default: true\n      },\n      speed: {\n        type: Number,\n        default: 0.5\n      },\n      realTime: {\n        type: Boolean,\n        default: false\n      },\n      stopPropagation: {\n        type: Boolean,\n        default: false\n      },\n      value: {\n        type: [String, Number, Array, Object],\n        default: 0\n      },\n      piecewiseLabel: {\n        type: Boolean,\n        default: false\n      },\n      debug: {\n        type: Boolean,\n        default: true\n      },\n      fixed: {\n        type: Boolean,\n        default: false\n      },\n      minRange: {\n        type: Number\n      },\n      maxRange: {\n        type: Number\n      },\n      processDragable: {\n        type: Boolean,\n        default: false\n      },\n      useKeyboard: {\n        type: Boolean,\n        default: false\n      },\n      actionsKeyboard: {\n        type: Array,\n        default () {\n          return [(i) => i - 1, (i) => i + 1]\n        }\n      },\n      piecewiseFilter: {\n        type: Function\n      },\n      tooltipMerge: {\n        type: Boolean,\n        default: true\n      },\n      startAnimation: {\n        type: Boolean,\n        default: false\n      },\n      enableCross: {\n        type: Boolean,\n        default: true\n      },\n      sliderStyle: [Array, Object, Function],\n      focusStyle: [Array, Object, Function],\n      tooltipDir: [Array, String],\n      formatter: [String, Function],\n      mergeFormatter: [String, Function],\n      piecewiseStyle: Object,\n      disabledStyle: Object,\n      piecewiseActiveStyle: Object,\n      processStyle: Object,\n      processClass: String,\n      bgStyle: Object,\n      tooltipStyle: [Array, Object, Function],\n      tooltipClass: String,\n      disabledDotStyle: [Array, Object, Function],\n      labelStyle: Object,\n      labelActiveStyle: Object\n    },\n    data () {\n      return {\n        flag: false,\n        dragFlag: false,\n        crossFlag: false,\n        keydownFlag: null,\n        focusFlag: false,\n        processFlag: false,\n        processSign: null,\n        size: 0,\n        fixedValue: 0,\n        focusSlider: 0,\n        currentValue: 0,\n        currentSlider: 0,\n        isComponentExists: true,\n        isMounted: false\n      }\n    },\n    computed: {\n      dotWidthVal () {\n        return typeof this.dotWidth === 'number' ? this.dotWidth : this.dotSize\n      },\n      dotHeightVal () {\n        return typeof this.dotHeight === 'number' ? this.dotHeight : this.dotSize\n      },\n      flowDirection () {\n        return `vue-slider-${this.direction + (this.reverse ? '-reverse' : '')}`\n      },\n      tooltipMergedPosition () {\n        if (!this.isMounted) return {}\n\n        const tooltipDirection = this.tooltipDirection[0]\n        const dot0 = this.$refs.dot0\n\n        if (dot0) {\n          if (this.direction === 'vertical') {\n            const style = {}\n            style[tooltipDirection] = `-${(this.dotHeightVal / 2) - (this.width / 2) + 9}px`\n            return style\n          } else {\n            const style = {}\n            style[tooltipDirection] = `-${(this.dotWidthVal / 2) - (this.height / 2) + 9}px`\n            style['left'] = `50%`\n            return style\n          }\n        }\n      },\n      tooltipDirection () {\n        const dir = this.tooltipDir || (this.direction === 'vertical' ? 'left' : 'top')\n        if (Array.isArray(dir)) {\n          return this.isRange ? dir : dir[1]\n        } else {\n          return this.isRange ? [dir, dir] : dir\n        }\n      },\n      tooltipStatus () {\n        return this.tooltip === 'hover' && this.flag ? 'vue-slider-always' : this.tooltip ? `vue-slider-${this.tooltip}` : ''\n      },\n      disabledArray () {\n        return Array.isArray(this.disabled) ? this.disabled : [this.disabled, this.disabled]\n      },\n      boolDisabled () {\n        return this.disabledArray.every(b => b === true)\n      },\n      isDisabled () {\n        return this.eventType === 'none' ? true : this.boolDisabled\n      },\n      disabledClass () {\n        return this.boolDisabled ? 'vue-slider-disabled' : ''\n      },\n      stateClass () {\n        return {\n          'vue-slider-state-process-drag': this.processFlag,\n          'vue-slider-state-drag': this.flag && !this.processFlag && !this.keydownFlag,\n          'vue-slider-state-focus': this.focusFlag\n        }\n      },\n      isRange () {\n        return Array.isArray(this.value)\n      },\n      slider () {\n        return this.isRange ? [this.$refs.dot0, this.$refs.dot1] : this.$refs.dot\n      },\n      minimum () {\n        return this.data ? 0 : this.min\n      },\n      val: {\n        get () {\n          return this.data ? (this.isRange ? [this.data[this.currentValue[0]], this.data[this.currentValue[1]]] : this.data[this.currentValue]) : this.currentValue\n        },\n        set (val) {\n          if (this.data) {\n            if (this.isRange) {\n              const index0 = this.data.indexOf(val[0])\n              const index1 = this.data.indexOf(val[1])\n              if (index0 > -1 && index1 > -1) {\n                this.currentValue = [index0, index1]\n              }\n            } else {\n              const index = this.data.indexOf(val)\n              if (index > -1) {\n                this.currentValue = index\n              }\n            }\n          } else {\n            this.currentValue = val\n          }\n        }\n      },\n      currentIndex () {\n        if (this.isRange) {\n          return this.data ? this.currentValue : [this.getIndexByValue(this.currentValue[0]), this.getIndexByValue(this.currentValue[1])]\n        } else {\n          return this.getIndexByValue(this.currentValue)\n        }\n      },\n      indexRange () {\n        if (this.isRange) {\n          return this.currentIndex\n        } else {\n          return [0, this.currentIndex]\n        }\n      },\n      maximum () {\n        return this.data ? (this.data.length - 1) : this.max\n      },\n      multiple () {\n        const decimals = `${this.interval}`.split('.')[1]\n        return decimals ? Math.pow(10, decimals.length) : 1\n      },\n      spacing () {\n        return this.data ? 1 : this.interval\n      },\n      total () {\n        if (this.data) {\n          return this.data.length - 1\n        } else if (Math.floor((this.maximum - this.minimum) * this.multiple) % (this.interval * this.multiple) !== 0) {\n          this.printError('Prop[interval] is illegal, Please make sure that the interval can be divisible')\n        }\n        return (this.maximum - this.minimum) / this.interval\n      },\n      gap () {\n        return this.size / this.total\n      },\n      position () {\n        return this.isRange ? [(this.currentValue[0] - this.minimum) / this.spacing * this.gap, (this.currentValue[1] - this.minimum) / this.spacing * this.gap] : ((this.currentValue - this.minimum) / this.spacing * this.gap)\n      },\n      isFixed () {\n        return this.fixed || this.minRange\n      },\n      limit () {\n        return this.isRange ? this.isFixed ? [[0, (this.total - this.fixedValue) * this.gap], [this.fixedValue * this.gap, this.size]] : [[0, this.position[1]], [this.position[0], this.size]] : [0, this.size]\n      },\n      valueLimit () {\n        return this.isRange ? this.isFixed ? [[this.minimum, this.maximum - (this.fixedValue * (this.spacing * this.multiple)) / this.multiple], [this.minimum + (this.fixedValue * (this.spacing * this.multiple)) / this.multiple, this.maximum]] : [[this.minimum, this.currentValue[1]], [this.currentValue[0], this.maximum]] : [this.minimum, this.maximum]\n      },\n      idleSlider () {\n        return this.currentSlider === 0 ? 1 : 0\n      },\n      wrapStyles () {\n        return this.direction === 'vertical' ? {\n          height: typeof this.height === 'number' ? `${this.height}px` : this.height,\n          padding: `${this.dotHeightVal / 2}px ${this.dotWidthVal / 2}px`\n        } : {\n          width: typeof this.width === 'number' ? `${this.width}px` : this.width,\n          padding: `${this.dotHeightVal / 2}px ${this.dotWidthVal / 2}px`\n        }\n      },\n      sliderStyles () {\n        if (Array.isArray(this.sliderStyle)) {\n          return this.isRange ? this.sliderStyle : this.sliderStyle[1]\n        } else if (typeof this.sliderStyle === 'function') {\n          return this.sliderStyle(this.val, this.currentIndex)\n        } else {\n          return this.isRange ? [this.sliderStyle, this.sliderStyle] : this.sliderStyle\n        }\n      },\n      focusStyles () {\n        if (Array.isArray(this.focusStyle)) {\n          return this.isRange ? this.focusStyle : this.focusStyle[1]\n        } else if (typeof this.focusStyle === 'function') {\n          return this.focusStyle(this.val, this.currentIndex)\n        } else {\n          return this.isRange ? [this.focusStyle, this.focusStyle] : this.focusStyle\n        }\n      },\n      disabledDotStyles () {\n        const disabledStyle = this.disabledDotStyle\n        if (Array.isArray(disabledStyle)) {\n          return disabledStyle\n        } else if (typeof disabledStyle === 'function') {\n          const style = disabledStyle(this.val, this.currentIndex)\n          return Array.isArray(style) ? style : [style, style]\n        } else if (disabledStyle) {\n          return [disabledStyle, disabledStyle]\n        } else {\n          return [{\n            backgroundColor: '#ccc'\n          }, {\n            backgroundColor: '#ccc'\n          }]\n        }\n      },\n      tooltipStyles () {\n        if (Array.isArray(this.tooltipStyle)) {\n          return this.isRange ? this.tooltipStyle : this.tooltipStyle[1]\n        } else if (typeof this.tooltipStyle === 'function') {\n          return this.tooltipStyle(this.val, this.currentIndex)\n        } else {\n          return this.isRange ? [this.tooltipStyle, this.tooltipStyle] : this.tooltipStyle\n        }\n      },\n      elemStyles () {\n        return this.direction === 'vertical' ? {\n          width: `${this.width}px`,\n          height: '100%'\n        } : {\n          height: `${this.height}px`\n        }\n      },\n      dotStyles () {\n        return this.direction === 'vertical' ? {\n          width: `${this.dotWidthVal}px`,\n          height: `${this.dotHeightVal}px`,\n          left: `${(-(this.dotWidthVal - this.width) / 2)}px`\n        } : {\n          width: `${this.dotWidthVal}px`,\n          height: `${this.dotHeightVal}px`,\n          top: `${(-(this.dotHeightVal - this.height) / 2)}px`\n        }\n      },\n      piecewiseDotStyle () {\n        return this.direction === 'vertical' ? {\n          width: `${this.width}px`,\n          height: `${this.width}px`\n        } : {\n          width: `${this.height}px`,\n          height: `${this.height}px`\n        }\n      },\n      piecewiseDotWrap () {\n        if (!this.piecewise && !this.piecewiseLabel) {\n          return false\n        }\n\n        let arr = []\n        for (let i = 0; i <= this.total; i++) {\n          const style = this.direction === 'vertical' ? {\n            bottom: `${this.gap * i - this.width / 2}px`,\n            left: 0\n          } : {\n            left: `${this.gap * i - this.height / 2}px`,\n            top: 0\n          }\n          const index = this.reverse ? (this.total - i) : i\n          const label = this.data ? this.data[index] : (this.spacing * index) + this.min\n          if (this.piecewiseFilter && !this.piecewiseFilter({ index, label })) {\n            continue\n          }\n          arr.push({\n            style,\n            index,\n            label: this.formatter ? this.formatting(label) : label\n          })\n        }\n        return arr\n      }\n    },\n    watch: {\n      value (val) {\n        this.flag || this.setValue(val, true)\n      },\n      max (val) {\n        if (val < this.min) {\n          return this.printError('The maximum value can not be less than the minimum value.')\n        }\n\n        const resetVal = this.limitValue(this.val)\n        this.setValue(resetVal)\n        this.refresh()\n      },\n      min (val) {\n        if (val > this.max) {\n          return this.printError('The minimum value can not be greater than the maximum value.')\n        }\n\n        const resetVal = this.limitValue(this.val)\n        this.setValue(resetVal)\n        this.refresh()\n      },\n      show (bool) {\n        if (bool && !this.size) {\n          this.$nextTick(() => {\n            this.refresh()\n          })\n        }\n      },\n      fixed () {\n        this.computedFixedValue()\n      },\n      minRange () {\n        this.computedFixedValue()\n      },\n      reverse () {\n        this.$refs.process.style.cssText = ''\n        this.refresh()\n      }\n    },\n    methods: {\n      bindEvents () {\n        document.addEventListener('touchmove', this.moving, {passive: false})\n        document.addEventListener('touchend', this.moveEnd, {passive: false})\n        document.addEventListener('mousedown', this.blurSlider)\n        document.addEventListener('mousemove', this.moving)\n        document.addEventListener('mouseup', this.moveEnd)\n        document.addEventListener('mouseleave', this.moveEnd)\n        document.addEventListener('keydown', this.handleKeydown)\n        document.addEventListener('keyup', this.handleKeyup)\n        window.addEventListener('resize', this.refresh)\n\n        if (this.isRange && this.tooltipMerge) {\n          this.$refs.dot0.addEventListener('transitionend', this.handleOverlapTooltip)\n          this.$refs.dot1.addEventListener('transitionend', this.handleOverlapTooltip)\n        }\n      },\n      unbindEvents () {\n        document.removeEventListener('touchmove', this.moving)\n        document.removeEventListener('touchend', this.moveEnd)\n        document.removeEventListener('mousedown', this.blurSlider)\n        document.removeEventListener('mousemove', this.moving)\n        document.removeEventListener('mouseup', this.moveEnd)\n        document.removeEventListener('mouseleave', this.moveEnd)\n        document.removeEventListener('keydown', this.handleKeydown)\n        document.removeEventListener('keyup', this.handleKeyup)\n        window.removeEventListener('resize', this.refresh)\n\n        if (this.isRange && this.tooltipMerge) {\n          this.$refs.dot0.removeEventListener('transitionend', this.handleOverlapTooltip)\n          this.$refs.dot1.removeEventListener('transitionend', this.handleOverlapTooltip)\n        }\n      },\n      handleKeydown (e) {\n        if (!this.useKeyboard || !this.focusFlag) {\n          return false\n        }\n        switch (e.keyCode) {\n        case 37:\n        case 40:\n          e.preventDefault()\n          this.keydownFlag = true\n          this.flag = true\n          this.changeFocusSlider(this.actionsKeyboard[0])\n          break\n        case 38:\n        case 39:\n          e.preventDefault()\n          this.keydownFlag = true\n          this.flag = true\n          this.changeFocusSlider(this.actionsKeyboard[1])\n          break\n        }\n      },\n      handleKeyup () {\n        if (this.keydownFlag) {\n          this.keydownFlag = false\n          this.flag = false\n        }\n      },\n      changeFocusSlider (fn) {\n        if (this.isRange) {\n          let arr = this.currentIndex.map((index, i) => {\n            if (i === this.focusSlider || this.fixed) {\n              const val = fn(index)\n              const range = this.fixed ? this.valueLimit[i] : [0, this.total]\n              if (val <= range[1] && val >= range[0]) {\n                return val\n              }\n            }\n            return index\n          })\n          if (arr[0] > arr[1]) {\n            this.focusSlider = this.focusSlider === 0 ? 1 : 0\n            arr = arr.reverse()\n          }\n          this.setIndex(arr)\n        } else {\n          this.setIndex(fn(this.currentIndex))\n        }\n      },\n      blurSlider (e) {\n        const dot = this.isRange ? this.$refs[`dot${this.focusSlider}`] : this.$refs.dot\n        if (!dot || dot === e.target || dot.contains(e.target)) {\n          return false\n        }\n        this.focusFlag = false\n      },\n      formatting (value) {\n        return typeof this.formatter === 'string' ? this.formatter.replace(/\\{value\\}/, value) : this.formatter(value)\n      },\n      mergeFormatting (value1, value2) {\n        return typeof this.mergeFormatter === 'string' ? this.mergeFormatter.replace(/\\{(value1|value2)\\}/g, (_, key) => key === 'value1' ? value1 : value2) : this.mergeFormatter(value1, value2)\n      },\n      getPos (e) {\n        this.realTime && this.getStaticData()\n        return this.direction === 'vertical' ? (this.reverse ? (e.pageY - this.offset) : (this.size - (e.pageY - this.offset))) : (this.reverse ? (this.size - (e.clientX - this.offset)) : (e.clientX - this.offset))\n      },\n      processClick (e) {\n        if (this.fixed) {\n          e.stopPropagation()\n        }\n      },\n      wrapClick (e) {\n        if (this.isDisabled || !this.clickable || this.processFlag || this.dragFlag) return false\n        const pos = this.getPos(e)\n        if (this.isRange) {\n          if (this.disabledArray.every(b => b === false)) {\n            this.currentSlider = pos > ((this.position[1] - this.position[0]) / 2 + this.position[0]) ? 1 : 0\n          } else if (this.disabledArray[0]) {\n            if (pos < this.position[0]) return false\n            this.currentSlider = 1\n          } else if (this.disabledArray[1]) {\n            if (pos > this.position[1]) return false\n            this.currentSlider = 0\n          }\n        }\n        if (this.disabledArray[this.currentSlider]) {\n          return false\n        }\n        this.setValueOnPos(pos)\n\n        if (this.isRange && this.tooltipMerge) {\n          const timer = setInterval(() => this.handleOverlapTooltip(), 16.7)\n          setTimeout(() => window.clearInterval(timer), this.speed * 1000)\n        }\n      },\n      moveStart (e, index = 0, isProcess) {\n        if (this.disabledArray[index]) {\n          return false\n        }\n        if (this.stopPropagation) {\n          e.stopPropagation()\n        }\n        if (this.isRange) {\n          this.currentSlider = index\n\n          if (isProcess) {\n            if (!this.processDragable) {\n              return false\n            }\n            this.processFlag = true\n            this.processSign = {\n              pos: this.position,\n              start: this.getPos((e.targetTouches && e.targetTouches[0]) ? e.targetTouches[0] : e)\n            }\n          }\n\n          if (!this.enableCross && this.val[0] === this.val[1]) {\n            this.crossFlag = true\n          }\n        }\n        if (!isProcess && this.useKeyboard) {\n          this.focusFlag = true\n          this.focusSlider = index\n        }\n        this.flag = true\n        this.$emit('drag-start', this)\n      },\n      moving (e) {\n        if (this.stopPropagation) {\n          e.stopPropagation()\n        }\n\n        if (!this.flag) return false\n        e.preventDefault()\n\n        if (e.targetTouches && e.targetTouches[0]) e = e.targetTouches[0]\n        if (this.processFlag) {\n          this.currentSlider = 0\n          this.setValueOnPos(this.processSign.pos[0] + this.getPos(e) - this.processSign.start, true)\n          this.currentSlider = 1\n          this.setValueOnPos(this.processSign.pos[1] + this.getPos(e) - this.processSign.start, true)\n        } else {\n          this.dragFlag = true\n          this.setValueOnPos(this.getPos(e), true)\n        }\n\n        if (this.isRange && this.tooltipMerge) {\n          this.handleOverlapTooltip()\n        }\n\n        this.$emit('drag', this)\n      },\n      moveEnd (e) {\n        if (this.stopPropagation) {\n          e.stopPropagation()\n        }\n        if (this.flag) {\n          this.$emit('drag-end', this)\n          if (this.lazy && this.isDiff(this.val, this.value)) {\n            this.syncValue()\n          }\n        } else {\n          return false\n        }\n        this.flag = false\n        window.setTimeout(() => {\n          this.crossFlag = false\n          this.dragFlag = false\n          this.processFlag = false\n        }, 0)\n        this.setPosition()\n      },\n      setValueOnPos (pos, isDrag) {\n        const range = this.isRange ? this.limit[this.currentSlider] : this.limit\n        const valueRange = this.isRange ? this.valueLimit[this.currentSlider] : this.valueLimit\n        const index = Math.round(pos / this.gap)\n        if (pos >= range[0] && pos <= range[1]) {\n          const v = this.getValueByIndex(index)\n          this.setTransform(pos)\n          this.setCurrentValue(v, isDrag)\n          if (this.isRange && (this.fixed || this.isLessRange(pos, index))) {\n            this.setTransform(pos + ((this.fixedValue * this.gap) * (this.currentSlider === 0 ? 1 : -1)), true)\n            this.setCurrentValue((v * this.multiple + (this.fixedValue * this.spacing * this.multiple * (this.currentSlider === 0 ? 1 : -1))) / this.multiple, isDrag, true)\n          }\n        } else {\n          const anotherSlider = pos < range[0] ? 0 : 1\n          const currentSlider = anotherSlider === 0 ? 1 : 0\n          this.setTransform(range[anotherSlider])\n          this.setCurrentValue(valueRange[anotherSlider])\n          if (this.isRange && (this.fixed || this.isLessRange(pos, index))) {\n            this.setTransform(this.limit[this.idleSlider][anotherSlider], true)\n            this.setCurrentValue(this.valueLimit[this.idleSlider][anotherSlider], isDrag, true)\n          } else if (this.isRange && (this.enableCross || this.crossFlag) && !this.isFixed && !this.disabledArray[anotherSlider] && this.currentSlider === currentSlider) {\n            this.focusSlider = anotherSlider\n            this.currentSlider = anotherSlider\n          }\n        }\n        this.crossFlag = false\n      },\n      isLessRange (pos, index) {\n        if (!this.isRange || (!this.minRange && !this.maxRange)) {\n          return false\n        }\n\n        const diff = this.currentSlider === 0 ? this.currentIndex[1] - index : index - this.currentIndex[0]\n        if (this.minRange && diff <= this.minRange) {\n          this.fixedValue = this.minRange\n          return true\n        }\n        if (this.maxRange && diff >= this.maxRange) {\n          this.fixedValue = this.maxRange\n          return true\n        }\n        this.computedFixedValue()\n        return false\n      },\n      isDiff (a, b) {\n        if (Object.prototype.toString.call(a) !== Object.prototype.toString.call(b)) {\n          return true\n        } else if (Array.isArray(a) && a.length === b.length) {\n          return a.some((v, i) => v !== b[i])\n        }\n        return a !== b\n      },\n      setCurrentValue (val, isDrag, isIdleSlider) {\n        const slider = isIdleSlider ? this.idleSlider : this.currentSlider\n        if (val < this.minimum || val > this.maximum) return false\n        if (this.isRange) {\n          if (this.isDiff(this.currentValue[slider], val)) {\n            this.currentValue.splice(slider, 1, val)\n            if (!this.lazy || !this.flag) {\n              this.syncValue()\n            }\n          }\n        } else if (this.isDiff(this.currentValue, val)) {\n          this.currentValue = val\n          if (!this.lazy || !this.flag) {\n            this.syncValue()\n          }\n        }\n        isDrag || this.setPosition()\n      },\n      getValueByIndex (index) {\n        return ((this.spacing * this.multiple) * index + (this.minimum * this.multiple)) / this.multiple\n      },\n      getIndexByValue (value) {\n        return Math.round((value - this.minimum) * this.multiple) / (this.spacing * this.multiple)\n      },\n      setIndex (val) {\n        if (Array.isArray(val) && this.isRange) {\n          let value\n          if (this.data) {\n            value = [this.data[val[0]], this.data[val[1]]]\n          } else {\n            value = [this.getValueByIndex(val[0]), this.getValueByIndex(val[1])]\n          }\n          this.setValue(value)\n        } else {\n          val = this.getValueByIndex(val)\n          if (this.isRange) {\n            this.currentSlider = val > ((this.currentValue[1] - this.currentValue[0]) / 2 + this.currentValue[0]) ? 1 : 0\n          }\n          this.setCurrentValue(val)\n        }\n      },\n      setValue (val, noCb, speed) {\n        if (this.isDiff(this.val, val)) {\n          const resetVal = this.limitValue(val)\n          this.val = this.isRange ? resetVal.concat() : resetVal\n          this.computedFixedValue()\n          this.syncValue(noCb)\n        }\n\n        this.$nextTick(() => this.setPosition(speed))\n      },\n      computedFixedValue () {\n        if (!this.isFixed) {\n          this.fixedValue = 0\n          return false\n        }\n\n        this.fixedValue = Math.max(this.fixed ? this.currentIndex[1] - this.currentIndex[0] : 0, this.minRange || 0)\n      },\n      setPosition (speed) {\n        this.flag || this.setTransitionTime(speed === undefined ? this.speed : speed)\n        if (this.isRange) {\n          this.setTransform(this.position[0], this.currentSlider === 1)\n          this.setTransform(this.position[1], this.currentSlider === 0)\n        } else {\n          this.setTransform(this.position)\n        }\n        this.flag || this.setTransitionTime(0)\n      },\n      setTransform (val, isIdleSlider) {\n        const slider = isIdleSlider ? this.idleSlider : this.currentSlider\n        const value = roundToDPR((this.direction === 'vertical' ? ((this.dotHeightVal / 2) - val) : (val - (this.dotWidthVal / 2))) * (this.reverse ? -1 : 1))\n        const translateValue = this.direction === 'vertical' ? `translateY(${value}px)` : `translateX(${value}px)`\n        const processSize = this.fixed ? `${this.fixedValue * this.gap}px` : `${slider === 0 ? this.position[1] - val : val - this.position[0]}px`\n        const processPos = this.fixed ? `${slider === 0 ? val : (val - this.fixedValue * this.gap)}px` : `${slider === 0 ? val : this.position[0]}px`\n        if (this.isRange) {\n          this.slider[slider].style.transform = translateValue\n          this.slider[slider].style.WebkitTransform = translateValue\n          this.slider[slider].style.msTransform = translateValue\n          if (this.direction === 'vertical') {\n            this.$refs.process.style.height = processSize\n            this.$refs.process.style[this.reverse ? 'top' : 'bottom'] = processPos\n          } else {\n            this.$refs.process.style.width = processSize\n            this.$refs.process.style[this.reverse ? 'right' : 'left'] = processPos\n          }\n        } else {\n          this.slider.style.transform = translateValue\n          this.slider.style.WebkitTransform = translateValue\n          this.slider.style.msTransform = translateValue\n          if (this.direction === 'vertical') {\n            this.$refs.process.style.height = `${val}px`\n            this.$refs.process.style[this.reverse ? 'top' : 'bottom'] = 0\n          } else {\n            this.$refs.process.style.width = `${val}px`\n            this.$refs.process.style[this.reverse ? 'right' : 'left'] = 0\n          }\n        }\n      },\n      setTransitionTime (time) {\n        // In order to avoid browser merge style and modify together\n        time || this.$refs.process.offsetWidth\n\n        if (this.isRange) {\n          for (let i = 0; i < this.slider.length; i++) {\n            this.slider[i].style.transitionDuration = `${time}s`\n            this.slider[i].style.WebkitTransitionDuration = `${time}s`\n          }\n          this.$refs.process.style.transitionDuration = `${time}s`\n          this.$refs.process.style.WebkitTransitionDuration = `${time}s`\n        } else {\n          this.slider.style.transitionDuration = `${time}s`\n          this.slider.style.WebkitTransitionDuration = `${time}s`\n          this.$refs.process.style.transitionDuration = `${time}s`\n          this.$refs.process.style.WebkitTransitionDuration = `${time}s`\n        }\n      },\n      limitValue (val) {\n        if (this.data) {\n          return val\n        }\n\n        const inRange = (v) => {\n          if (v < this.min) {\n            this.printError(`The value of the slider is ${val}, the minimum value is ${this.min}, the value of this slider can not be less than the minimum value`)\n            return this.min\n          } else if (v > this.max) {\n            this.printError(`The value of the slider is ${val}, the maximum value is ${this.max}, the value of this slider can not be greater than the maximum value`)\n            return this.max\n          }\n          return v\n        }\n\n        if (this.isRange) {\n          return val.map((v) => inRange(v))\n        } else {\n          return inRange(val)\n        }\n      },\n      isActive (index) {\n        return index >= this.indexRange[0] && index <= this.indexRange[1]\n      },\n      syncValue (noCb) {\n        let val = this.isRange ? this.val.concat() : this.val\n        this.$emit('input', val)\n        this.keydownFlag && this.$emit('on-keypress', val)\n        noCb || this.$emit('callback', val)\n      },\n      getValue () {\n        return this.val\n      },\n      getIndex () {\n        return this.currentIndex\n      },\n      getStaticData () {\n        if (this.$refs.elem) {\n          this.size = this.direction === 'vertical' ? this.$refs.elem.offsetHeight : this.$refs.elem.offsetWidth\n          this.offset = this.direction === 'vertical' ? (this.$refs.elem.getBoundingClientRect().top + window.pageYOffset || document.documentElement.scrollTop) : this.$refs.elem.getBoundingClientRect().left\n        }\n      },\n      refresh () {\n        if (this.$refs.elem) {\n          this.getStaticData()\n          this.computedFixedValue()\n          this.setPosition(0)\n        }\n      },\n      printError (msg) {\n        if (this.debug) {\n          console.error(`[VueSlider error]: ${msg}`)\n        }\n      },\n      handleOverlapTooltip () {\n        const isDirectionSame = this.tooltipDirection[0] === this.tooltipDirection[1]\n\n        if (this.isRange && isDirectionSame) {\n          const tooltip0 = this.reverse ? this.$refs.tooltip1 : this.$refs.tooltip0\n          const tooltip1 = this.reverse ? this.$refs.tooltip0 : this.$refs.tooltip1\n          const tooltip0Rect = tooltip0.getBoundingClientRect()\n          const tooltip1Rect = tooltip1.getBoundingClientRect()\n\n          const tooltip0Right = tooltip0Rect.right\n          const tooltip1Left = tooltip1Rect.left\n\n          const tooltip0Y = tooltip0Rect.top\n          const tooltip1Y = tooltip1Rect.top + tooltip1Rect.height\n\n          const horizontalOverlap = this.direction === 'horizontal' && tooltip0Right > tooltip1Left\n          const verticalOverlap = this.direction === 'vertical' && tooltip1Y > tooltip0Y\n\n          if (horizontalOverlap || verticalOverlap) {\n            this.handleDisplayMergedTooltip(true)\n          } else {\n            this.handleDisplayMergedTooltip(false)\n          }\n        }\n      },\n      handleDisplayMergedTooltip (show) {\n        const tooltip0 = this.$refs.tooltip0\n        const tooltip1 = this.$refs.tooltip1\n        const mergedTooltip = this.$refs.process.getElementsByClassName('vue-merged-tooltip')[0]\n\n        if (show) {\n          tooltip0.style.visibility = 'hidden'\n          tooltip1.style.visibility = 'hidden'\n          mergedTooltip.style.visibility = 'inherit'\n        } else {\n          tooltip0.style.visibility = 'inherit'\n          tooltip1.style.visibility = 'inherit'\n          mergedTooltip.style.visibility = 'hidden'\n        }\n      }\n    },\n    mounted () {\n      this.isComponentExists = true\n\n      if (typeof window === 'undefined' || typeof document === 'undefined') {\n        return this.printError('window or document is undefined, can not be initialization.')\n      }\n\n      this.$nextTick(() => {\n        if (this.isComponentExists) {\n          this.getStaticData()\n          this.setValue(this.limitValue(this.value), true, this.startAnimation ? this.speed : 0)\n          this.bindEvents()\n\n          if (this.isRange && this.tooltipMerge && !this.startAnimation) {\n            this.$nextTick(() => {\n              this.handleOverlapTooltip()\n            })\n          }\n        }\n      })\n\n      this.isMounted = true\n    },\n    beforeDestroy () {\n      this.isComponentExists = false\n      this.unbindEvents()\n    }\n  }\n</script>\n\n<style>\n  .vue-slider-component {\n    position: relative;\n    box-sizing: border-box;\n    user-select: none;\n    -webkit-user-select:none;\n    -moz-user-select:none;\n    -o-user-select:none;\n  }\n  .vue-slider-component.vue-slider-disabled {\n    opacity: .5;\n    cursor: not-allowed;\n  }\n  .vue-slider-component.vue-slider-has-label {\n    margin-bottom: 15px;\n  }\n  .vue-slider-component.vue-slider-disabled .vue-slider-dot {\n    cursor: not-allowed;\n  }\n  .vue-slider-component .vue-slider {\n    position: relative;\n    display: block;\n    border-radius: 15px;\n    background-color: #ccc;\n  }\n  .vue-slider-component .vue-slider::after {\n    content: '';\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    z-index: 2;\n  }\n  .vue-slider-component .vue-slider-process {\n    position: absolute;\n    border-radius: 15px;\n    background-color: #3498db;\n    transition: all 0s;\n    z-index: 1;\n  }\n  .vue-slider-component .vue-slider-process.vue-slider-process-dragable {\n    cursor: pointer;\n    z-index: 3;\n  }\n  .vue-slider-component.vue-slider-horizontal .vue-slider-process {\n    width: 0;\n    height: 100%;\n    top: 0;\n    left: 0;\n    will-change: width;\n  }\n  .vue-slider-component.vue-slider-vertical .vue-slider-process {\n    width: 100%;\n    height: 0;\n    bottom: 0;\n    left: 0;\n    will-change: height;\n  }\n  .vue-slider-component.vue-slider-horizontal-reverse .vue-slider-process {\n    width: 0;\n    height: 100%;\n    top: 0;\n    right: 0;\n  }\n  .vue-slider-component.vue-slider-vertical-reverse .vue-slider-process {\n    width: 100%;\n    height: 0;\n    top: 0;\n    left: 0;\n  }\n  .vue-slider-component .vue-slider-dot {\n    position: absolute;\n    transition: all 0s;\n    will-change: transform;\n    cursor: pointer;\n    z-index: 5;\n  }\n  .vue-slider-component .vue-slider-dot .vue-slider-dot-handle {\n    width: 100%;\n    height: 100%;\n    border-radius: 50%;\n    background-color: #fff;\n    box-shadow: 0.5px 0.5px 2px 1px rgba(0, 0, 0, 0.32);\n  }\n  .vue-slider-component .vue-slider-dot.vue-slider-dot-focus .vue-slider-dot-handle {\n    box-shadow: 0 0 2px 1px #3498db;\n  }\n  .vue-slider-component .vue-slider-dot.vue-slider-dot-dragging {\n    z-index: 5;\n  }\n  .vue-slider-component .vue-slider-dot.vue-slider-dot-disabled {\n    z-index: 4;\n  }\n  .vue-slider-component.vue-slider-horizontal .vue-slider-dot {\n    left: 0;\n  }\n  .vue-slider-component.vue-slider-vertical .vue-slider-dot {\n    bottom: 0;\n  }\n  .vue-slider-component.vue-slider-horizontal-reverse .vue-slider-dot {\n    right: 0;\n  }\n  .vue-slider-component.vue-slider-vertical-reverse .vue-slider-dot {\n    top: 0;\n  }\n  .vue-slider-component .vue-slider-tooltip-wrap {\n    display: none;\n    position: absolute;\n    z-index: 9;\n  }\n  .vue-slider-component .vue-slider-tooltip {\n    display: block;\n    font-size: 14px;\n    white-space: nowrap;\n    padding: 2px 5px;\n    min-width: 20px;\n    text-align: center;\n    color: #fff;\n    border-radius: 5px;\n    border: 1px solid #3498db;\n    background-color: #3498db;\n  }\n  .vue-slider-component .vue-slider-tooltip-wrap.vue-slider-tooltip-top {\n    top: -9px;\n    left: 50%;\n    transform: translate(-50%, -100%);\n  }\n  .vue-slider-component .vue-slider-tooltip-wrap.vue-slider-tooltip-bottom {\n    bottom: -9px;\n    left: 50%;\n    transform: translate(-50%, 100%);\n  }\n  .vue-slider-component .vue-slider-tooltip-wrap.vue-slider-tooltip-left {\n    top: 50%;\n    left: -9px;\n    transform: translate(-100%, -50%);\n  }\n  .vue-slider-component .vue-slider-tooltip-wrap.vue-slider-tooltip-right {\n    top: 50%;\n    right: -9px;\n    transform: translate(100%, -50%);\n  }\n  .vue-slider-component .vue-slider-tooltip-wrap.vue-slider-tooltip-top .vue-slider-tooltip::before,\n  .vue-slider-component .vue-slider-tooltip-top .vue-merged-tooltip .vue-slider-tooltip::before {\n    content: '';\n    position: absolute;\n    bottom: -10px;\n    left: 50%;\n    width: 0;\n    height: 0;\n    border: 5px solid transparent;\n    border: 6px solid transparent\\0;\n    border-top-color: inherit;\n    transform: translate(-50%, 0);\n  }\n  .vue-slider-component .vue-slider-tooltip-wrap.vue-merged-tooltip {\n    display: block;\n    visibility: hidden;\n  }\n  .vue-slider-component .vue-slider-tooltip-wrap.vue-slider-tooltip-bottom .vue-slider-tooltip::before,\n  .vue-slider-component .vue-slider-tooltip-bottom .vue-merged-tooltip .vue-slider-tooltip::before {\n    content: '';\n    position: absolute;\n    top: -10px;\n    left: 50%;\n    width: 0;\n    height: 0;\n    border: 5px solid transparent;\n    border: 6px solid transparent\\0;\n    border-bottom-color: inherit;\n    transform: translate(-50%, 0);\n  }\n  .vue-slider-component .vue-slider-tooltip-wrap.vue-slider-tooltip-left .vue-slider-tooltip::before,\n  .vue-slider-component .vue-slider-tooltip-left .vue-merged-tooltip .vue-slider-tooltip::before {\n    content: '';\n    position: absolute;\n    top: 50%;\n    right: -10px;\n    width: 0;\n    height: 0;\n    border: 5px solid transparent;\n    border: 6px solid transparent\\0;\n    border-left-color: inherit;\n    transform: translate(0, -50%);\n  }\n  .vue-slider-component .vue-slider-tooltip-wrap.vue-slider-tooltip-right .vue-slider-tooltip::before,\n  .vue-slider-component .vue-slider-tooltip-right .vue-merged-tooltip .vue-slider-tooltip::before {\n    content: '';\n    position: absolute;\n    top: 50%;\n    left: -10px;\n    width: 0;\n    height: 0;\n    border: 5px solid transparent;\n    border: 6px solid transparent\\0;\n    border-right-color: inherit;\n    transform: translate(0, -50%);\n  }\n  .vue-slider-component .vue-slider-dot.vue-slider-hover:hover .vue-slider-tooltip-wrap {\n    display: block;\n  }\n  .vue-slider-component .vue-slider-dot.vue-slider-always .vue-slider-tooltip-wrap {\n    display: block!important;\n  }\n  .vue-slider-component .vue-slider-piecewise {\n    position: absolute;\n    width: 100%;\n    padding: 0;\n    margin: 0;\n    left: 0;\n    top: 0;\n    height: 100%;\n    list-style: none;\n  }\n  .vue-slider-component .vue-slider-piecewise-item {\n    position: absolute;\n    width: 8px;\n    height: 8px;\n  }\n  .vue-slider-component .vue-slider-piecewise-dot {\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    width: 100%;\n    height: 100%;\n    display: inline-block;\n    background-color: rgba(0, 0, 0, 0.16);\n    border-radius: 50%;\n    transform: translate(-50%, -50%);\n    z-index: 2;\n    transition: all .3s;\n  }\n  .vue-slider-component .vue-slider-piecewise-item:first-child .vue-slider-piecewise-dot, .vue-slider-component .vue-slider-piecewise-item:last-child .vue-slider-piecewise-dot {\n    visibility: hidden;\n  }\n  .vue-slider-component.vue-slider-horizontal .vue-slider-piecewise-label, .vue-slider-component.vue-slider-horizontal-reverse .vue-slider-piecewise-label {\n    position: absolute;\n    display: inline-block;\n    top: 100%;\n    left: 50%;\n    white-space: nowrap;\n    font-size: 12px;\n    color: #333;\n    transform: translate(-50%, 8px);\n    visibility: visible;\n  }\n  .vue-slider-component.vue-slider-vertical .vue-slider-piecewise-label, .vue-slider-component.vue-slider-vertical-reverse .vue-slider-piecewise-label {\n    position: absolute;\n    display: inline-block;\n    top: 50%;\n    left: 100%;\n    white-space: nowrap;\n    font-size: 12px;\n    color: #333;\n    transform: translate(8px, -50%);\n    visibility: visible;\n  }\n  .vue-slider-component .vue-slider-sr-only {\n    clip: rect(1px, 1px, 1px, 1px);\n    height: 1px;\n    width: 1px;\n    overflow: hidden;\n    position: absolute !important;\n  }\n</style>\n"]}]}